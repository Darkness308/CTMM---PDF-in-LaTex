#!/usr/bin/env python3
"""
CTMM Document Conversion Pipeline
Converts Word documents and Markdown files to LaTeX format with CTMM styling.

This script:
1. Scans therapie-material/ directory for Word documents and Markdown files
2. Converts them to LaTeX format using pandoc and LibreOffice
3. Applies CTMM-specific formatting and styling
4. Saves converted files to converted/ directory
5. Generates conversion reports and quality metrics
"""

import os
import subprocess
import sys
import re
import shutil
from pathlib import Path
from typing import List, Dict, Tuple
import argparse
import logging
import tempfile
import json
from datetime import datetime

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('conversion.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

class CTMMDocumentConverter:
    def __init__(self, source_dir: str = "therapie-material", target_dir: str = "converted"):
        self.source_dir = Path(source_dir)
        self.target_dir = Path(target_dir)
        self.conversion_stats = {
            "total_files": 0,
            "successful_conversions": 0,
            "failed_conversions": 0,
            "conversion_details": []
        }
        
        # Ensure target directory exists
        self.target_dir.mkdir(exist_ok=True)
        
    def _sanitize_filename(self, filename: str) -> str:
        """Convert filename to LaTeX-safe format."""
        # Remove file extension
        name = Path(filename).stem
        # Replace spaces and special characters
        name = re.sub(r'[^\w\s-]', '', name)
        name = re.sub(r'[-\s]+', ' ', name)
        return name.strip()
    
    def _extract_text_from_docx(self, docx_path: Path) -> str:
        """Extract text from DOCX file using LibreOffice."""
        try:
            with tempfile.TemporaryDirectory() as temp_dir:
                # Convert DOCX to HTML first
                html_file = Path(temp_dir) / f"{docx_path.stem}.html"
                
                cmd = [
                    "libreoffice", "--headless", "--convert-to", "html",
                    "--outdir", temp_dir, str(docx_path)
                ]
                
                result = subprocess.run(cmd, capture_output=True, text=True, timeout=60)
                if result.returncode != 0:
                    logger.error(f"LibreOffice conversion failed for {docx_path}: {result.stderr}")
                    return ""
                
                # Check if HTML file was created
                html_files = list(Path(temp_dir).glob("*.html"))
                if not html_files:
                    logger.error(f"No HTML file generated for {docx_path}")
                    return ""
                
                html_file = html_files[0]
                
                # Convert HTML to Markdown using pandoc
                cmd = ["pandoc", "-f", "html", "-t", "markdown", str(html_file)]
                result = subprocess.run(cmd, capture_output=True, text=True)
                
                if result.returncode != 0:
                    logger.error(f"Pandoc conversion failed: {result.stderr}")
                    return ""
                
                return result.stdout
                
        except subprocess.TimeoutExpired:
            logger.error(f"Conversion timeout for {docx_path}")
            return ""
        except Exception as e:
            logger.error(f"Error converting {docx_path}: {str(e)}")
            return ""
    
    def _convert_markdown_to_latex(self, markdown_content: str, title: str) -> str:
        """Convert Markdown content to LaTeX with CTMM styling."""
        try:
            # Use pandoc to convert markdown to latex
            cmd = ["pandoc", "-f", "markdown", "-t", "latex", "--wrap=none"]
            result = subprocess.run(cmd, input=markdown_content, capture_output=True, text=True)
            
            if result.returncode != 0:
                logger.error(f"Pandoc LaTeX conversion failed: {result.stderr}")
                return ""
            
            latex_content = result.stdout
            
            # Apply CTMM-specific formatting
            latex_content = self._apply_ctmm_formatting(latex_content, title)
            
            return latex_content
            
        except Exception as e:
            logger.error(f"Error converting markdown to LaTeX: {str(e)}")
            return ""
    
    def _apply_ctmm_formatting(self, latex_content: str, title: str) -> str:
        """Apply CTMM-specific formatting to LaTeX content."""
        
        # Create CTMM-styled LaTeX document
        ctmm_header = f"""% Converted CTMM Therapy Document: {title}
% Generated by CTMM Document Conversion Pipeline
% Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

\\section{{{title}}}
\\label{{sec:{title.lower().replace(' ', '-')}}}

"""
        
        # Apply CTMM styling transformations
        formatted_content = latex_content
        
        # Replace standard LaTeX elements with CTMM equivalents
        replacements = [
            # Convert subsections to CTMM styled headers
            (r'\\subsection\{([^}]+)\}', r'\\subsection{\\textcolor{ctmmBlue}{\\faBook~\\1}}'),
            (r'\\subsubsection\{([^}]+)\}', r'\\subsubsection{\\textcolor{ctmmGreen}{\\faList~\\1}}'),
            
            # Convert itemize/enumerate to CTMM colors
            (r'\\begin\{itemize\}', r'\\begin{itemize}[label=\\textcolor{ctmmOrange}{\\faArrowRight}]'),
            
            # Convert emphasis to CTMM colors
            (r'\\textbf\{([^}]+)\}', r'\\textbf{\\textcolor{ctmmBlue}{\\1}}'),
            (r'\\emph\{([^}]+)\}', r'\\textcolor{ctmmGreen}{\\textit{\\1}}'),
            
            # Add CTMM checkboxes
            (r'\[\s*\]', r'\\checkbox'),
            (r'\[x\]', r'\\checkedbox'),
            
            # Convert quotes to CTMM boxes
            (r'\\begin\{quote\}(.*?)\\end\{quote\}', 
             r'\\begin{ctmmBlueBox}{Wichtiger Hinweis}\\1\\end{ctmmBlueBox}'),
        ]
        
        for pattern, replacement in replacements:
            formatted_content = re.sub(pattern, replacement, formatted_content, flags=re.DOTALL)
        
        # Add some structure improvements
        if "trigger" in title.lower():
            formatted_content = self._add_trigger_specific_elements(formatted_content)
        elif "depression" in title.lower():
            formatted_content = self._add_depression_specific_elements(formatted_content)
        
        return ctmm_header + formatted_content
    
    def _add_trigger_specific_elements(self, content: str) -> str:
        """Add trigger-specific CTMM elements."""
        trigger_intro = """
\\begin{ctmmGreenBox}{Trigger-Management System}
Dieses Modul ist Teil des CTMM Trigger-Management Systems.
\\quickNav{ctmmOrange}{Siehe auch: Notfallkarten und Safewords}
\\end{ctmmGreenBox}

"""
        return trigger_intro + content
    
    def _add_depression_specific_elements(self, content: str) -> str:
        """Add depression-specific CTMM elements."""
        depression_intro = """
\\begin{ctmmBlueBox}{Depression und Stimmungstief}
Dieses Modul behandelt Depressionen im Kontext neurodiverser Beziehungen.
\\quickNav{ctmmPurple}{Siehe auch: Selbstreflexion und Arbeitsblätter}
\\end{ctmmBlueBox}

"""
        return depression_intro + content
    
    def convert_document(self, file_path: Path) -> Tuple[bool, str]:
        """Convert a single document to LaTeX format."""
        logger.info(f"Converting document: {file_path.name}")
        
        try:
            title = self._sanitize_filename(file_path.name)
            
            # Extract content based on file type
            if file_path.suffix.lower() == '.docx':
                markdown_content = self._extract_text_from_docx(file_path)
            elif file_path.suffix.lower() == '.md':
                with open(file_path, 'r', encoding='utf-8') as f:
                    markdown_content = f.read()
            else:
                logger.warning(f"Unsupported file type: {file_path.suffix}")
                return False, f"Unsupported file type: {file_path.suffix}"
            
            if not markdown_content.strip():
                logger.warning(f"No content extracted from {file_path.name}")
                return False, "No content extracted"
            
            # Convert to LaTeX
            latex_content = self._convert_markdown_to_latex(markdown_content, title)
            
            if not latex_content.strip():
                logger.warning(f"LaTeX conversion failed for {file_path.name}")
                return False, "LaTeX conversion failed"
            
            # Save to converted directory
            output_file = self.target_dir / f"{title}.tex"
            with open(output_file, 'w', encoding='utf-8') as f:
                f.write(latex_content)
            
            logger.info(f"Successfully converted {file_path.name} -> {output_file.name}")
            return True, f"Converted to {output_file.name}"
            
        except Exception as e:
            error_msg = f"Error converting {file_path.name}: {str(e)}"
            logger.error(error_msg)
            return False, error_msg
    
    def convert_all_documents(self) -> Dict:
        """Convert all documents in source directory."""
        logger.info(f"Starting conversion of all documents in {self.source_dir}")
        
        # Find all convertible files
        file_patterns = ['*.docx', '*.md']
        files_to_convert = []
        
        for pattern in file_patterns:
            files_to_convert.extend(self.source_dir.glob(pattern))
        
        # Add README.md if it exists in root
        readme_path = Path("README.md")
        if readme_path.exists():
            files_to_convert.append(readme_path)
        
        self.conversion_stats["total_files"] = len(files_to_convert)
        
        logger.info(f"Found {len(files_to_convert)} files to convert")
        
        # Convert each file
        for file_path in files_to_convert:
            success, message = self.convert_document(file_path)
            
            conversion_detail = {
                "file": str(file_path),
                "success": success,
                "message": message,
                "timestamp": datetime.now().isoformat()
            }
            
            self.conversion_stats["conversion_details"].append(conversion_detail)
            
            if success:
                self.conversion_stats["successful_conversions"] += 1
            else:
                self.conversion_stats["failed_conversions"] += 1
        
        # Save conversion report
        self._save_conversion_report()
        
        return self.conversion_stats
    
    def _save_conversion_report(self):
        """Save detailed conversion report."""
        report_file = self.target_dir / "conversion_report.json"
        
        with open(report_file, 'w', encoding='utf-8') as f:
            json.dump(self.conversion_stats, f, indent=2, ensure_ascii=False)
        
        # Also create a human-readable report
        readable_report = self.target_dir / "conversion_report.md"
        
        with open(readable_report, 'w', encoding='utf-8') as f:
            f.write("# CTMM Document Conversion Report\n\n")
            f.write(f"**Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")
            f.write(f"## Summary\n\n")
            f.write(f"- **Total files:** {self.conversion_stats['total_files']}\n")
            f.write(f"- **Successful conversions:** {self.conversion_stats['successful_conversions']}\n")
            f.write(f"- **Failed conversions:** {self.conversion_stats['failed_conversions']}\n")
            f.write(f"- **Success rate:** {(self.conversion_stats['successful_conversions']/max(1,self.conversion_stats['total_files'])*100):.1f}%\n\n")
            
            f.write("## Conversion Details\n\n")
            
            for detail in self.conversion_stats["conversion_details"]:
                status = "✅" if detail["success"] else "❌"
                f.write(f"- {status} **{Path(detail['file']).name}**: {detail['message']}\n")
        
        logger.info(f"Conversion report saved to {readable_report}")

def main():
    parser = argparse.ArgumentParser(description="Convert CTMM therapy documents to LaTeX")
    parser.add_argument("--source", "-s", default="therapie-material", 
                       help="Source directory containing documents to convert")
    parser.add_argument("--target", "-t", default="converted",
                       help="Target directory for converted LaTeX files")
    parser.add_argument("--file", "-f", 
                       help="Convert specific file instead of all files")
    parser.add_argument("--verbose", "-v", action="store_true",
                       help="Enable verbose logging")
    
    args = parser.parse_args()
    
    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)
    
    converter = CTMMDocumentConverter(args.source, args.target)
    
    if args.file:
        # Convert single file
        file_path = Path(args.file)
        if not file_path.exists():
            logger.error(f"File not found: {file_path}")
            sys.exit(1)
        
        success, message = converter.convert_document(file_path)
        if success:
            logger.info(f"Conversion successful: {message}")
        else:
            logger.error(f"Conversion failed: {message}")
            sys.exit(1)
    else:
        # Convert all documents
        stats = converter.convert_all_documents()
        
        logger.info("=== CONVERSION SUMMARY ===")
        logger.info(f"Total files: {stats['total_files']}")
        logger.info(f"Successful: {stats['successful_conversions']}")
        logger.info(f"Failed: {stats['failed_conversions']}")
        
        if stats['failed_conversions'] > 0:
            logger.warning(f"{stats['failed_conversions']} conversions failed")
            sys.exit(1)
        else:
            logger.info("All conversions completed successfully!")

if __name__ == "__main__":
    main()